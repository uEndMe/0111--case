0111--项目流程

#### 准备

* 项目描述

```
项目描述：
	1. 项目简介：描述，解决需求，使用操作
	2. 技术栈：
		react框架，antdUI库，Axios请求...
		ES6语法，webpack构建工具，可视化图表Echarts...
	3. 主要功能：权限、用户管理，商品、商品分类管理，国际化

技术选型：
	技术总监指定使用的技术栈；	
	
前端路由
	一般由公司搭建；
	
API接口
	前后台通讯的 url 地址
	接口文档：请求类型，请求参数，请求令牌...
```



* 测试接口

```
Postman 工具
测试/联调/对接/接口
...
```



* git 版本控制

```js
配置 npm/yarn
建仓库 
初始化本地,搭建脚手架
	git add .
	git commit -m "xxx"
	git remote add origin pathxxx
	//git remote remove origin
	git push origin master
```

```
克隆
	git clone pathxxx
```

```
已有分支
	git fetch origin xxx:xxx
	git checkout xxx
没有分支
	git checkout -b devxxx
```

```
开发：
本地版本控制：
	git add . 
	git commit -m "xxx"
提交到仓库：
	git push origin pathxxx
	失败
		网络问题，本地没有版本控制
		需要更新：
			git pull origin xxx
```



* 项目目录

```
src
	api 请求
	assets 公共资源
	component UI组件
	config 配置文件
	containers 容器组件
	i18n 国际化
	redux 模块redux
	utils 工具模块
	App.jsx
	index.js
```



#### 配置

##### antd 配置

```js
//antd 官网：
https://ant.design/docs/react/use-with-create-react-app-cn
yran add antd
```

```js
//详见官网文档，此处仅供参考
//自定义配置 react-app-rewired 
yarn add react-app-rewired customize-cra
1. 修改启动方式 package.json
2. 创建 config-overrides.js 配置

//按需加载 react-app-rewired 
yarn add babel-plugin-import
1. 修改 config-overrides.js 文件
2. 引入 antd, 重启

//自定义主题
yarn add less less-loader
1. 修改 config-overrides.js 文件，重启
```



* 配置 ES7 语法装饰， 路径别名

```js
//config-overrides.js
//1. 解构引入 addDecoratorsLegacy, addWebpackAlias
yarn add @babel/plugin-proposal-decorators --dev
```

```js
module.exports = override(
    //语法装饰
    addDecoratorsLegacy(),
    //路径别名    
    addWebpackAlias({
        //...
    })
);
```



* 基本页面

```js
//index.js
引入：react, react-dom, app
渲染：app
//app.js
引入：react
暴露：app
```



##### router 配置

```
yarn add react-router-dom
```

```jsx
//app.jsx
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Home from './components/home';
import Login from './components/login';
...
	return <Router>
    	<Switch>
            <Route path='/login' exact component={ login }/>
            <Route path='/' exact component={ Home }/>
    	</Switch>
	</Router>
//Switch: 单匹配 （默认多匹配）
//exact: 全匹配 （默认半匹配）
```

```
home页面，login页面 基本配置
```



##### redux 配置

```
yarn add redux react-redux redux-thunk
yarn add redux-devtools-extension --dev
```

```
创建 redux 文件夹： actions / store / reducers
```

```js
//actions.js
//创建 action 对象，的工厂函数
//....
```

```js
//store.js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import { composeWithDevTools } from 'redux-devtools-extension';

import reducers from './reducers';

export default createStore(
    reducers,
    process.env.NODE_ENV === 'development'
    	? composeWithDevTools(applyMiddleware(thunk))
    	: applyMiddleware(thunk)
)
```

```js
//reducers
//根据 prevState 和 action 返回 newState 
import { combineReducers } from 'redux';

function aaa(prevState=0, action) {
    switch (action.type){
        case(1):
            return prevState + action.data ;
        default:
            return prevState;
    }
}
export default combineReducers({
    aaa,
    bbb
})
```

```js
//action-types.js
//定义 action type
/...
```

```jsx
//index.js
import { Provider } from 'react-redux';
import store from './redux/store';
...
	<Provider store={store}>
        <App />
    </ Provider>
```



#### login

* 静态组件

```
1. 引入图片  
2. 使用 antd 组件
3. prefix 前缀，引入图标组件（type 指定图标）
4. 指定主题色：type="parimary"
```

```
1. 添加 className,在 less 中书写，引入
```



* 表单校验

```js
//From 属性
	//高阶组件：给被包装组件传递from属性
	//form: getFieldDecorator/resetFields/validateFields...
From.create()(Login)

//ES7 装饰器 简写
@Form.create()
Login...
export default Login
```

```js
//字段修饰（表单校验)
const { getFieldDecorator } = this.props.form;

//简单校验
//Item...
getFieldDecorator(
    //类型
    'username',
    //规则对象
    { rules:[
        { required:true, message:'xxx' }
        //min,max,pattern...
    ] }
)(<Input / >)
        
//自定复杂校验
//自定校验规则
validator = (rule, value, callback) => {
    //rule.field：输入域键 ('username') 方便复用
    const key = rule.field;
    //value: 输入域值 value
    if(!value){
    	//callback: 传参数，失败信息
		callback(`${key}不能为空`);
    }else{
        //callback: 不传参，验证成功
        callback();
    }
}
//Item...
getFieldDecorator(
	'username',
	{ rules:[
  		//规则：验证器
		{ validator: this.validator }
	]}
)(<Input / >)
```



* 请求

```
yarn add axios
```

```js
//引入axios;
//引入{ message } 'antd'
//from绑定：onSbumit={this.login}
//button设置: htmlType='submit'
login = e => {
    e.preventDefault();
    //err 校验信息，values 表单数据
    this.props.form.validateFields((err,values)=>{
        //校验失败
        if(err)return
        //发请求,请求登录
        const { username,password } = values
        axios.post(
            //发送请求到代理服务器
            '/api/login',
            { username,password }
        )
        .then(response=>{
            //请求成功
			console.log(reponse);
            if(response.data.status === 0){
                //登录成功
                //跳转到home页面
                //1. 路由链接跳转(只能用于render方法中)
                	//return <Rdirect to='/' />
                //2. 编程式导航
                this.props.history.replace('/');
            }else {
                //登录失败
                message.error(response.data.msg)
                //清空密码 resetFields
            	this.props.form.resetFields(['password']);
            }
        })
        .catch(e{
            console.log(e);
            //请求失败
            message.error('网络错误~');
        }
    })
}
```



* 跨域问题

```js
//检查响应地址，不同源则报错
服务器代理方案：
	* 客户端 》 代理服务器 》 服务器 》 代理服务器 》 客户端
	* 客户端和代理服务器符合同源策略
    * 代理服务器和目标服务器不存在跨域问题

使用：
	在package.json 加上 "proxy": "目标服务器地址"，重启
    //httP://47.103.203.152
```



* 封装请求函数

```
//封装请求的公共参数；

```



* 配置 axios 拦截器

```
拦截请求/响应的函数
作用：
  请求拦截器：
	设置公共的请求头/参数
    
执行流程：
	1. 执行请求拦截器 》》 发送请求
	2. 执行响应拦截器 》》 响应函数

axios发送POST请求：
	默认content-type: application/json 请求体是json
		有可能 content-type: appliction/x-www-form-urlencodeed
		则传参 data: 'username=admin&password-admin'
	拦截器可以统一转换参数；
```



```js
//引入 axios 是 Axios 的实例
//自定义 axios 实例
const axiosInstance = axios.create({
    baseURL: '/api',	//公共路径：所有路径以 baseURL 开头；
    timeout: 2000,		//20s, 请求超时
    headers: { 			//公共请求头
        //参数必须写死
    }
})
```

```js
//设置拦截器
//请求拦截器（发送之前）
axiosInstance.interceptors.request.use(
    //代码成功
	(config)=>{
        //config 对象，包含所有请求配置
        //修改 config 配置
        //添加动态 headers 参数
        if(token){
            config.headers.authorization = `Bearer ${token}`
        }
        //如果必须使用 www 方式发送请求；
        //修改请求参数
        //对象 ==》 字符串 a=a&b=b
        if(config.method === 'post'){
            const keys = Object.keys(config.data);
            keys.reduce((prev,curr)=>{
                prev += prev + `&${curr}=${config.data[curr]}`
                return prev;
            },'').slice(1);
            config.data = data;
            config.headers['content-type'] = 
                'appliction/x-www-form-urlencodeed';
        }
        return config
    }
    //代码失败（一般不会出问题，一般没用）
    //(e)=>{ return Promise.reject(e); }
)
//响应拦截器（响应之后，触发then,cateh之前）
axiosInstance.interceptors.response.use(
    //响应成功 ==》 2xx
	(response)=>{ 
        return response;
    }
    //响应失败 ==》 
    ()=>{}
)
```



* 封装 axios

```js
//request
import axios from 'axios';

const axiosInstance = axios.create({
	baseURL: '/api',
	timeout: 20000,
	header:{
	
	}
})

//请求拦截器
axiosInstance.interceptors.request.use(
	(config) => {
        let token = '';
		if(token){
			config.headers.authoriztion = `Bearer ${token}`;
		}
        //wwww请求 处理
        if(config.method === 'post'){
            Object.kes(config.data)
           	.reduce((p,c)=>{
                p += `&${c}=${config.data[c]}`;
                return p;
            },'')
            .slice(1);
           config.headers['content-type'] = 
                'appliction/x-www-form-urlencodeed';
        }
	}
)

//响应拦截器
axiosInstance.interceptors.response.use(
	(response) => {
        if(response.data.status === 0){
            return response.data.data;
        }else{
            return Promise.reject(response.data.msg);
        }
	},
    (err) => {
        const errCode = {
            401: '没有权限',
            403: '禁止访问',
            404; '资源丢失',
            500: '服务器故障'
        };
        let errMsg = '';
    	if(err.response){
            errMsg = errCode[err.response.status];
        }else{
            if(rr.message.indexOf('Netword Error') !== -1){
                errMsg = '网络故障';
            }else if (err.message.indexOf('timeout') !== -1){
                errMsg = '连接超时'
            }
        }	
        return Promise.reject(errMsg || '未知错误' );
	}
)
```



* 封装请求功能的函数

```js
api / index.js

import axiosInstance from './request';
export const reqLogin = (username,password) => {
	axiosInstance({
		url:'/login',
		method:'POST',
		data:{
			username,
			password
		}
	})
}
```

```





```





* 用户数据存储

```
存储： localStorage 和 redux
读取： 先从localStorage 中读取，存在 redux 中，后面



```

* 工具函数 utils

```js
storage.js
const localStotage = window.localStorage;
function getItem(key){
	const value = localStorage.getItem(key);
    try{
        return JSON.parse(value);
    }catch (e){
        console.log(e);
		return JSON.parse(value);
    }
}

function setItem(key,value){
	value = JSON.stringify(value);
	localStorage.setItem(key,value);
}

function removeItem(){

}
```

